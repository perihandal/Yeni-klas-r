import React, { useEffect, useRef } from "react";
import Map from "ol/Map";
import View from "ol/View";
import TileLayer from "ol/layer/Tile";
import OSM from "ol/source/OSM";
import { get as getProjection, transform } from "ol/proj";
import "ol/ol.css";

import Draw from "ol/interaction/Draw";
import Translate from "ol/interaction/Translate";
import VectorLayer from "ol/layer/Vector";
import VectorSource from "ol/source/Vector";
import { Feature } from "ol";
import { Geometry } from "ol/geom";
import { WKT } from "ol/format";
import { Style, Fill, Stroke, Circle, Text, Icon } from "ol/style";
import Overlay from "ol/Overlay";
import { defaults as defaultInteractions } from "ol/interaction";
import { Collection } from "ol";

// Geometri tipini tanƒ±mla
export interface GeometryItem {
  id?: string | number;
  name?: string;
  type?: string;
  wkt: string;
  highlighted?: boolean;
  area?: number;
  length?: number;
  centroid?: string;
  boundingBox?: string;
  startPoint?: string;
  endPoint?: string;
}


interface MapViewProps {
  geometryType: string;
  onDrawEnd?: (wkt: string) => void;
  geometries?: GeometryItem[];
  zoomToGeometry?: { wkt: string; name?: string } | null;
  onDeleteGeometry?: (id: number) => void;
  onUpdateGeometry?: (geometry: GeometryItem) => void;
  onMoveGeometry?: (id: number, newWkt: string) => void;
  popupOpen?: boolean; // Popup durumu
}

// Pin/marker stillerini olu≈ütur
const createFeatureStyle = (feature: Feature, geometryType: string, isHighlighted: boolean = false) => {
  const fillColor = getColorByType(geometryType);
  const strokeColor = darkenColor(fillColor);
  
  if (geometryType === 'Point') {
    // Pin ikonunu kullan
    const iconStyle = new Style({
      image: new Icon({
        src: '/pin.png',
        scale: 0.03, // Ultra k√º√ß√ºk boyut
        anchor: [0.5, 1], // Pin'in alt ucu koordinata hizalanƒ±r
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      }),
      text: new Text({
        text: feature.get('name') || '',
        offsetY: -10, // Ultra k√º√ß√ºk pin i√ßin minimal offset
        fill: new Fill({ color: isHighlighted ? '#ff0000' : '#000' }),
        stroke: new Stroke({ 
          color: isHighlighted ? '#ffff00' : '#fff', 
          width: isHighlighted ? 2 : 1 
        }),
        font: isHighlighted ? 'bold 11px Arial' : '10px Arial'
      })
    });
    
    return iconStyle;
  } else if (geometryType === 'LineString') {
    return new Style({
      stroke: new Stroke({
        color: strokeColor,
        width: 3
      })
    });
  } else if (geometryType === 'Polygon') {
    return new Style({
      fill: new Fill({ 
        color: fillColor + '40'
      }),
      stroke: new Stroke({ 
        color: strokeColor, 
        width: 2
      })
    });
  }
  
  // Varsayƒ±lan stil
  return new Style({
    image: new Circle({
      radius: 6,
      fill: new Fill({ color: '#ff0000' }),
      stroke: new Stroke({ color: '#ffffff', width: 2 })
    })
  });
};

// Geometri tipine g√∂re renk
const getColorByType = (type: string): string => {
  switch (type) {
    case 'Point': return '#e74c3c';
    case 'LineString': return '#3498db';
    case 'Polygon': return '#2ecc71';
    default: return '#f39c12';
  }
};

// Rengi koyula≈ütƒ±r
const darkenColor = (color: string): string => {
  const colorMap: { [key: string]: string } = {
    '#e74c3c': '#c0392b',
    '#3498db': '#2980b9',
    '#2ecc71': '#27ae60',
    '#f39c12': '#e67e22'
  };
  return colorMap[color] || color;
};


const MapView: React.FC<MapViewProps> = ({ 
  geometryType, 
  onDrawEnd, 
  geometries = [], 
  zoomToGeometry = null,
  onDeleteGeometry,
  onUpdateGeometry,
  onMoveGeometry,
  popupOpen = false
}) => {
  const mapRef = useRef<HTMLDivElement | null>(null);
  const mapInstance = useRef<Map | null>(null);
  const drawRef = useRef<Draw | null>(null);
  const translateRef = useRef<Translate | null>(null);
  const vectorSourceRef = useRef<VectorSource | null>(null);
  const popupRef = useRef<HTMLDivElement | null>(null);
  const popupOverlayRef = useRef<Overlay | null>(null);
  const [mapInitialized, setMapInitialized] = React.useState(true);
  const [mapError, setMapError] = React.useState<string | null>(null);
  const [moveMode, setMoveMode] = React.useState<{ active: boolean; geometryId?: number }>({ active: false });
  const [popupContent, setPopupContent] = React.useState<{ 
    id?: string | number;
    name: string; 
    type: string; 
    wkt: string;
    area?: number;
    length?: number;
    centroid?: string;
    boundingBox?: string;
    startPoint?: string;
    endPoint?: string;
  } | null>(null);
  const hoverTimeoutRef = useRef<number | null>(null);

  // Ta≈üƒ±ma modunu aktifle≈ütir
  const activateMoveMode = (id: number) => {
    console.log("üñêÔ∏è Ta≈üƒ±ma modu aktifle≈ütiriliyor, ID:", id);
    
    if (!mapInstance.current || !vectorSourceRef.current) {
      alert("Harita hen√ºz hazƒ±r deƒüil!");
      return;
    }
    
    // √ñnceki ta≈üƒ±ma interaction'ƒ±nƒ± temizle
    if (translateRef.current) {
      mapInstance.current.removeInteraction(translateRef.current);
      translateRef.current = null;
    }
    
    // Ta≈üƒ±ma modunu aktifle≈ütir
    setMoveMode({ active: true, geometryId: id });
    
    // Ta≈üƒ±ma interaction'ƒ±nƒ± olu≈ütur
    const targetFeature = vectorSourceRef.current.getFeatures().find(feature => feature.get('id') === id);
    if (targetFeature) {
      translateRef.current = new Translate({
        features: new Collection([targetFeature])
      });
    } else {
      alert("Ta≈üƒ±nacak geometri bulunamadƒ±!");
      return;
    }
    
    // Ta≈üƒ±ma tamamlandƒ±ƒüƒ±nda
    translateRef.current.on('translateend', (event) => {
      const feature = event.features.getArray()[0];
      if (feature && onMoveGeometry) {
        const geometry = feature.getGeometry();
        if (geometry) {
          // WKT formatƒ±na √ßevir
          const wktFormat = new WKT();
          const newWkt = wktFormat.writeGeometry(geometry, {
            dataProjection: 'EPSG:4326',
            featureProjection: 'EPSG:3857'
          });
          
          console.log("üîÑ Geometri ta≈üƒ±ndƒ±:", {
            id: feature.get('id'),
            oldWkt: feature.get('wkt'),
            newWkt: newWkt
          });
          
          // Backend'e yeni WKT'yi g√∂nder
          onMoveGeometry(id, newWkt);
          
          // Feature'ƒ±n WKT'sini g√ºncelle
          feature.set('wkt', newWkt);
        }
      }
      
      // Ta≈üƒ±ma modunu kapat
      setMoveMode({ active: false });
      if (translateRef.current) {
        mapInstance.current!.removeInteraction(translateRef.current);
        translateRef.current = null;
      }
      
      alert("Geometri ba≈üarƒ±yla ta≈üƒ±ndƒ±!");
    });
    
    // Ta≈üƒ±ma interaction'ƒ±nƒ± haritaya ekle
    mapInstance.current.addInteraction(translateRef.current);
    
    alert("Ta≈üƒ±ma modu aktifle≈ütirildi! Geometriyi s√ºr√ºkleyebilirsiniz.");
  };

  // Geometrileri haritada g√∂ster
  useEffect(() => {
    if (!vectorSourceRef.current) {
      return;
    }
    
    try {
      vectorSourceRef.current!.clear();
        
        if (geometries.length > 0) {
          console.log(`MapView - ${geometries.length} geometri i≈ülenecek`);
        const wktFormat = new WKT();
        geometries.forEach((g, index) => {
          try {
            console.log(`\nüîç Geometri ${index + 1} analizi:`, {
              name: g.name,
              type: g.type,
              originalWkt: g.wkt,
              wktType: typeof g.wkt,
              wktLength: g.wkt?.length
            });
            
            // WKT string'inin ba≈üƒ±nda SRID bilgisi var mƒ± kontrol et
            let wktString = g.wkt;
            let projection = 'EPSG:4326';
            
            // Null veya undefined kontrol
            if (!wktString) {
              console.error(`‚ùå Geometri ${index + 1}: WKT verisi bo≈ü`);
              return;
            }
            
            // String olmayan WKT'yi string'e √ßevir
            if (typeof wktString !== 'string') {
              wktString = String(wktString);
            }
            
            // SRID=xxxx; formatƒ±nƒ± kontrol et
            if (wktString.includes('SRID=')) {
              const sridMatch = wktString.match(/SRID=(\d+);/);
              if (sridMatch) {
                const srid = parseInt(sridMatch[1]);
                // Sadece ge√ßerli SRID'leri kabul et
                if ([4326, 3857, 32636, 32637, 32638, 32639, 32640, 32641, 32642, 32643, 32644, 32645, 32646, 32647, 32648, 32649, 32650, 32651, 32652, 32653, 32654, 32655, 32656, 32657, 32658, 32659, 32660].includes(srid)) {
                  projection = `EPSG:${srid}`;
                  wktString = wktString.replace(/SRID=\d+;/, '');
                  console.log(`‚úÖ Ge√ßerli SRID bulundu: EPSG:${srid}`);
                } else {
                  console.warn(`‚ö†Ô∏è Ge√ßersiz SRID: ${srid}, varsayƒ±lan EPSG:4326 kullanƒ±lƒ±yor`);
                  projection = 'EPSG:4326';
                  wktString = wktString.replace(/SRID=\d+;/, '');
                }
              }
            }
            
            let feature;
            try {
              feature = wktFormat.readFeature(wktString, { 
                dataProjection: projection, 
                featureProjection: 'EPSG:3857' 
              });
              
              // Projection kontrol√º
              const geometry = feature.getGeometry();
              if (geometry) {
                const coords = (geometry as any).getCoordinates?.();
                // Koordinatlarƒ±n ge√ßerli olup olmadƒ±ƒüƒ±nƒ± kontrol et
                if (coords && Array.isArray(coords)) {
                  const isValid = coords.every(coord => 
                    Array.isArray(coord) && coord.every(c => typeof c === 'number' && isFinite(c))
                  );
                  if (!isValid) {
                    console.warn(`‚ö†Ô∏è Ge√ßersiz koordinatlar: ${JSON.stringify(coords)}`);
                    return;
                  }
                }
              }
            } catch (err) {
              console.error(`‚ùå WKT okuma hatasƒ± (${projection}):`, err);
              // Fallback olarak EPSG:4326 dene
              try {
                feature = wktFormat.readFeature(wktString, { 
                  dataProjection: 'EPSG:4326', 
                  featureProjection: 'EPSG:3857' 
                });
                console.log(`‚úÖ EPSG:4326 ile ba≈üarƒ±lƒ± okuma`);
              } catch (fallbackErr) {
                console.error(`‚ùå Fallback okuma da ba≈üarƒ±sƒ±z:`, fallbackErr);
                return;
              }
            }
            

            
            // Feature geometrisini kontrol et
            const geometry = feature.getGeometry();
            if (!geometry) {
              console.error(`‚ùå Geometri ${index + 1}: Feature geometrisi bo≈ü`);
              return;
            }
            
            // Koordinatlarƒ± kontrol et (geometry tipine g√∂re)
            let coordinates: any = null;
            if (geometry.getType() === 'Point') {
              coordinates = (geometry as any).getCoordinates();
            } else if (geometry.getType() === 'LineString') {
              coordinates = (geometry as any).getCoordinates();
            } else if (geometry.getType() === 'Polygon') {
              coordinates = (geometry as any).getCoordinates();
            }

            
            // Feature'a bilgileri ekle
            if (g.id) {
              feature.set('id', g.id);
            }
            if (g.name) {
              feature.set('name', g.name);
            }
            if (g.type) {
              feature.set('type', g.type);
            } else {
              // Eƒüer tip belirtilmemi≈üse WKT'den √ßƒ±kar
              const wktType = wktString.split('(')[0].trim();
              feature.set('type', wktType);
            }
            
            // Highlight bilgisini ekle
            const isHighlighted = g.highlighted || false;
            feature.set('highlighted', isHighlighted);
            
            // WKT bilgisini de ekle
            feature.set('wkt', g.wkt);
            

            
            // Feature'a stil uygula
            const featureStyle = createFeatureStyle(feature, feature.get('type') || 'Point', isHighlighted);
            feature.setStyle(featureStyle);
            
            // Feature'ƒ± ekle
            vectorSourceRef.current!.addFeature(feature);

          } catch (err) {
            console.error('‚ùå Geometry format hatasƒ±:', {
              name: g.name,
              wkt: g.wkt,
              error: err
            });
          }
        });
        
        const totalFeatures = vectorSourceRef.current.getFeatures().length;
        console.log(`üìä Haritada ${totalFeatures} geometri y√ºklendi`);
        
        // Harita g√∂r√ºn√ºm alanƒ±nƒ± ayarla
        if (mapInstance.current && totalFeatures > 0) {
          const view = mapInstance.current.getView();
          const vectorExtent = vectorSourceRef.current.getExtent();
          
          // Geometrilerin extent'ine zoom yap
          if (vectorExtent && vectorExtent.every(val => isFinite(val))) {
            view.fit(vectorExtent, { 
              padding: [20, 20, 20, 20],
              duration: 500, // Animasyon s√ºresini kƒ±salt
              easing: (t: number) => t // Linear easing kullan
            });
            console.log("üìç Geometrilerin extent'ine zoom yapƒ±ldƒ±");
          }
        }
      } else {
        console.log("‚ö†Ô∏è Hi√ß geometri bulunamadƒ±");
      }
    } catch (err) {
      console.error('üî• Geometri g√∂r√ºnt√ºleme hatasƒ±:', err);
    }
  }, [geometries]);

  // Belirli geometriye zoom yapma
  useEffect(() => {
    if (!mapInstance.current || !zoomToGeometry) {
      return;
    }
    
    try {
      const wktFormat = new WKT();
      let feature;
      
      // SRID kontrol√º
      let wktString = zoomToGeometry.wkt;
      let projection = 'EPSG:4326';
      
      if (wktString.includes('SRID=')) {
        const sridMatch = wktString.match(/SRID=(\d+);/);
        if (sridMatch) {
          const srid = parseInt(sridMatch[1]);
          if ([4326, 3857, 32636, 32637, 32638, 32639, 32640, 32641, 32642, 32643, 32644, 32645, 32646, 32647, 32648, 32649, 32650, 32651, 32652, 32653, 32654, 32655, 32656, 32657, 32658, 32659, 32660].includes(srid)) {
            projection = `EPSG:${srid}`;
            wktString = wktString.replace(/SRID=\d+;/, '');
          }
        }
      }
      
      try {
        feature = wktFormat.readFeature(wktString, {
          dataProjection: projection,
          featureProjection: 'EPSG:3857'
        });
      } catch (err) {
        // Fallback olarak EPSG:4326 dene
        feature = wktFormat.readFeature(wktString, {
          dataProjection: 'EPSG:4326',
          featureProjection: 'EPSG:3857'
        });
      }
      
      const geometry = feature.getGeometry();
      if (!geometry) {
        console.error("‚ùå Zoom i√ßin geometri olu≈üturulamadƒ±");
        return;
      }
      
      const extent = geometry.getExtent();
      const view = mapInstance.current.getView();
      
      console.log("üì¶ Zoom extent:", extent);
      
      // Geometri tipine g√∂re zoom yap
      if (geometry.getType() === 'Point') {
        const coordinates = (geometry as any).getCoordinates();
        view.setCenter(coordinates);
        view.setZoom(15);
        console.log(`üìç Nokta i√ßin zoom`);
      } else {
        // Diƒüer geometriler i√ßin fit kullan
        view.fit(extent, {
          padding: [20, 20, 20, 20],
          duration: 500, // Animasyon s√ºresini kƒ±salt
          easing: (t: number) => t // Linear easing kullan
        });
        console.log(`üìè √áizgi/alan i√ßin fit zoom`);
      }
      
      // Zoom tamamlandƒ±ktan sonra bilgi ver
      setTimeout(() => {
        console.log("‚úÖ Zoom tamamlandƒ±:", {
          name: zoomToGeometry.name,
          newCenter: view.getCenter(),
          newZoom: view.getZoom(),
          geometryType: geometry.getType()
        });
      }, 1600);
      
    } catch (err) {
      console.error("‚ùå Zoom hatasƒ±:", err);
    }
  }, [zoomToGeometry]);

  // Harita ba≈ülatma
  useEffect(() => {
    if (mapRef.current && !mapInstance.current) {
      try {
        vectorSourceRef.current = new VectorSource();
        const vectorLayer = new VectorLayer({ 
          source: vectorSourceRef.current,
          style: (feature: any) => {
            const featureType = feature.get('type') || 'Point';
            const isHighlighted = feature.get('highlighted') || false;
            return createFeatureStyle(feature as Feature, featureType, isHighlighted);
          },
          renderBuffer: 50, // Render buffer'ƒ± artƒ±r
          updateWhileAnimating: true, // Animasyon sƒ±rasƒ±nda g√ºncellemeyi a√ß
          updateWhileInteracting: true, // Etkile≈üim sƒ±rasƒ±nda g√ºncellemeyi a√ß
          zIndex: 1
        });
        
        // Popup overlay olu≈ütur
        if (popupRef.current) {
          popupOverlayRef.current = new Overlay({
            element: popupRef.current
          });
        }

        mapInstance.current = new Map({
          target: mapRef.current,
        layers: [
          new TileLayer({ 
            source: new OSM(),
            zIndex: 0
          }),
          vectorLayer,
        ],
        overlays: popupOverlayRef.current ? [popupOverlayRef.current] : [],
        interactions: defaultInteractions({
          doubleClickZoom: true,
          dragPan: true,
          mouseWheelZoom: true,
          pinchZoom: true,
          keyboard: true
        }),
        view: new View({
          center: transform([0, 0], 'EPSG:4326', 'EPSG:3857'), // Merkezi doƒüru projection'da ayarla
          zoom: 2,
          projection: 'EPSG:3857', // A√ßƒ±k√ßa projection belirt
          enableRotation: false, // Rotasyonu kapat
          constrainOnlyCenter: true, // Sadece merkezi sƒ±nƒ±rla
          multiWorld: false // √áoklu d√ºnya desteƒüini kapat
        }),
        pixelRatio: window.devicePixelRatio || 1 // Device pixel ratio kullan
      });

        // Mouse hover event'leri ekle
        let currentFeature: any = null;
        
        // Zoom event'lerini kaldƒ±r - titre≈üime neden oluyor
        // mapInstance.current.getView().on('change:resolution', () => {
        //   isZooming = true;
        //   if (popupOverlayRef.current) {
        //     popupOverlayRef.current.setPosition(undefined);
        //     setPopupContent(null);
        //   }
        // });
        
        // mapInstance.current.getView().on('change:center', () => {
        //   setTimeout(() => {
        //     isZooming = false;
        //   }, 1000);
        // });
        
        // Mouse hover event'leri ekle - optimize edilmi≈ü
        let isZooming = false;
        let hoverTimeout: number | null = null;
        
        // Zoom durumunu takip et
        mapInstance.current.getView().on('change:resolution', () => {
          isZooming = true;
          // Zoom sƒ±rasƒ±nda popup'ƒ± gizle
          if (popupOverlayRef.current) {
            popupOverlayRef.current.setPosition(undefined);
            setPopupContent(null);
          }
          // Zoom bittikten sonra popup'ƒ± tekrar g√∂ster
          setTimeout(() => {
            isZooming = false;
          }, 300);
        });
        
        mapInstance.current.on('pointermove', (evt) => {
          // Zoom sƒ±rasƒ±nda hover i≈ülemini yapma
          if (isZooming) {
            return;
          }
          
          // Hover timeout'unu temizle
          if (hoverTimeout) {
            clearTimeout(hoverTimeout);
          }
          
          // Hover i≈ülemini geciktir
          hoverTimeout = window.setTimeout(() => {
            const feature = mapInstance.current!.forEachFeatureAtPixel(evt.pixel, (feature) => feature);
            
            // Popup'ƒ±n √ºzerindeyse hi√ßbir ≈üey yapma
            if (popupRef.current && popupRef.current.contains(evt.originalEvent.target as Node)) {
              return;
            }
            
            // Eƒüer aynƒ± feature √ºzerindeyse hi√ßbir ≈üey yapma
            if (feature === currentFeature) {
              return;
            }
            
            currentFeature = feature;
            
            // Hover i≈ülemini yap
            if (feature && popupOverlayRef.current) {
              const name = feature.get('name') || 'ƒ∞simsiz';
              const type = feature.get('type') || 'Bilinmeyen';
              const coordinates = evt.coordinate;
              
              // Geometri verilerini bul
              const geometryData = geometries.find(g => g.name === name && g.type === type);
              
              setPopupContent({
                id: feature.get('id') || geometryData?.id,
                name: name,
                type: type,
                wkt: feature.get('wkt') || 'WKT bilgisi yok',
                area: geometryData?.area,
                length: geometryData?.length,
                centroid: geometryData?.centroid,
                boundingBox: geometryData?.boundingBox,
                startPoint: geometryData?.startPoint,
                endPoint: geometryData?.endPoint
              });
              
              popupOverlayRef.current.setPosition(coordinates);
            } else if (popupOverlayRef.current) {
              popupOverlayRef.current.setPosition(undefined);
              setPopupContent(null);
            }
          }, 50); // 50ms gecikme
        });

        // Mouse wheel event'ini test et
        mapRef.current.addEventListener('wheel', (e) => {
          // Zoom sƒ±rasƒ±nda gereksiz log'larƒ± kaldƒ±r
        });

        // Harita y√ºklenme kontrol√º
        mapInstance.current.on('rendercomplete', () => {
          setMapInitialized(true);
          setMapError(null);
        });

        // Harita hazƒ±r
        setMapInitialized(true);

        // Tile y√ºkleme hata kontrol√º
        mapInstance.current.getLayers().forEach(layer => {
          if (layer instanceof TileLayer) {
            layer.getSource()?.on('tileloaderror', () => {
              setMapError('Harita katmanlarƒ± y√ºklenemedi. ƒ∞nternet baƒülantƒ±nƒ±zƒ± kontrol edin.');
            });
          }
        });

      } catch (err) {
        console.error('Harita ba≈ülatma hatasƒ±:', err);
        setMapError('Harita ba≈ülatƒ±lamadƒ±: ' + (err as Error).message);
      }
    }
    
    return () => {
      // Timeout'larƒ± temizle
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
      
      if (mapInstance.current) {
        mapInstance.current.setTarget(undefined);
        mapInstance.current = null;
      }
    };
  }, []);

  // √áizim interaction'ƒ±
  useEffect(() => {
    if (!mapInstance.current || !vectorSourceRef.current) {
      return;
    }
    
    console.log(`üé® √áizim modu durumu: ${geometryType ? 'Aktif' : 'Pasif'}`);
    
    // Mevcut √ßizim interaction'ƒ±nƒ± kaldƒ±r
    if (drawRef.current) {
      mapInstance.current.removeInteraction(drawRef.current);
      drawRef.current = null;
      console.log("üóëÔ∏è √áizim interaction'ƒ± kaldƒ±rƒ±ldƒ±");
    }
    
    // Sadece geometryType varsa ve bo≈ü string deƒüilse √ßizim interaction'ƒ± ekle
    if (geometryType && geometryType.trim() !== "") {
      try {
      drawRef.current = new Draw({
        source: vectorSourceRef.current,
        type: geometryType as any,
          style: createFeatureStyle(new Feature(), geometryType)
      });
      mapInstance.current.addInteraction(drawRef.current);
      console.log(`‚úÖ √áizim interaction'ƒ± eklendi: ${geometryType}`);
        
      drawRef.current.on('drawend', (evt) => {
          try {
        const feature = (evt as any).feature as Feature<Geometry>;
            
            // √áizilen feature'a tip bilgisi ekle
            feature.set('type', geometryType);
            
            // Stil uygula
            const featureStyle = createFeatureStyle(feature, geometryType);
            feature.setStyle(featureStyle);
            
            const wkt = new WKT().writeFeature(feature, {
              dataProjection: 'EPSG:4326',
              featureProjection: 'EPSG:3857'
            });
            
            // WKT'nin ge√ßerli olup olmadƒ±ƒüƒ±nƒ± kontrol et
            if (!wkt || wkt.length < 10) {
              console.error('‚ùå Ge√ßersiz WKT olu≈üturuldu:', wkt);
              return;
            }
            
            // WKT'yi doƒürudan kullan
            const finalWkt = wkt;
            
            console.log(`üé® √áizilen geometri WKT:`, {
              type: geometryType,
              originalWkt: wkt,
              finalWkt: finalWkt,
              wktLength: wkt.length,
              isValid: wkt && wkt.length > 10
            });
            
            console.log(`üé® √áizilen geometriye stil uygulandƒ±:`, {
              type: geometryType,
              hasStyle: !!feature.getStyle(),
              isPoint: geometryType === 'Point',
              usingIcon: geometryType === 'Point' ? 'pin.png' : false
            });
            
            // Draw interaction'ƒ± zaten feature'ƒ± otomatik olarak ekliyor
            console.log(`‚úÖ √áizilen feature hazƒ±r:`, {
              type: geometryType,
              geometry: feature.getGeometry()?.getType(),
              coordinates: (feature.getGeometry() as any)?.getCoordinates?.()
            });
            
            // LineString √ßizimi tamamlandƒ±ysa sadece LineString'i g√∂nder
            if (geometryType === 'LineString' && onDrawEnd) {
              console.log('üîó LineString g√∂nderiliyor:', finalWkt);
              onDrawEnd(finalWkt);
            } else if (onDrawEnd) {
              onDrawEnd(finalWkt);
            }
          } catch (err) {
            console.error('√áizim tamamlama hatasƒ±:', err);
        }
      });
      } catch (err) {
        console.error('√áizim interaction hatasƒ±:', err);
      }
    }
    
    // Temizlik
    return () => {
      if (drawRef.current && mapInstance.current) {
        mapInstance.current.removeInteraction(drawRef.current);
      }
    };
  }, [geometryType, onDrawEnd]);

  return (
    <div style={{ 
      width: "100%", 
      height: "100%", 
      minHeight: 0, 
      position: "relative",
      overflow: "hidden", // Overflow'u gizle
      pointerEvents: !popupOpen ? "auto" : "none" // Popup a√ßƒ±kken mouse event'leri engelle
    }}>
      <div 
        ref={mapRef} 
        className="ol-map-container" 
        style={{ 
          width: "100%", 
          height: "100%", 
          minHeight: 0,
          willChange: "transform", // GPU hƒ±zlandƒ±rma
          backfaceVisibility: "hidden", // Backface'i gizle
          pointerEvents: !popupOpen ? "auto" : "none" // Popup a√ßƒ±kken mouse event'leri engelle
        }} 
      />
      {mapError && (
        <div style={{
          position: "absolute",
          top: "10px",
          left: "10px",
          right: "10px",
          background: "#ff5722",
          color: "white",
          padding: "10px",
          borderRadius: "4px",
          zIndex: 1000,
          fontSize: "14px"
        }}>
          {mapError}
        </div>
      )}
      {!mapInitialized && !mapError && (
        <div style={{
          position: "absolute",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          background: "rgba(255,255,255,0.9)",
          padding: "20px",
          borderRadius: "8px",
          fontSize: "16px",
          color: "#666"
        }}>
          Harita y√ºkleniyor...
        </div>
      )}
      
      {/* Ta≈üƒ±ma Modu G√∂stergesi */}
      {moveMode.active && (
        <div style={{
          position: "absolute",
          top: "10px",
          left: "50%",
          transform: "translateX(-50%)",
          background: "#ff9800",
          color: "white",
          padding: "8px 16px",
          borderRadius: "4px",
          fontSize: "14px",
          fontWeight: "bold",
          zIndex: 1000,
          boxShadow: "0 2px 8px rgba(0,0,0,0.3)"
        }}>
          üñêÔ∏è Ta≈üƒ±ma Modu Aktif - Geometriyi s√ºr√ºkleyin
        </div>
      )}
      
            {/* Popup Element */}
      <div
        ref={popupRef}
        style={{
          background: "white",
          border: "2px solid #1976d2",
          borderRadius: "8px",
          padding: "12px",
          fontSize: "14px",
          boxShadow: "0 4px 12px rgba(0,0,0,0.3)",
          maxWidth: "300px",
          display: popupContent ? "block" : "none",
          position: "relative",
          zIndex: 10000,
          pointerEvents: "auto" // Mouse eventlerini etkinle≈ütir
        }}
        onMouseEnter={() => {
          // Popup'ƒ±n √ºzerindeyken hover timeout'unu temizle
          if (hoverTimeoutRef.current) {
            clearTimeout(hoverTimeoutRef.current);
          }
        }}
        onMouseLeave={() => {
          // Popup'tan √ßƒ±kƒ±nca popup'ƒ± kapat
          setTimeout(() => {
            if (popupOverlayRef.current) {
              popupOverlayRef.current.setPosition(undefined);
              setPopupContent(null);
            }
          }, 200);
        }}
      >
        {popupContent && (
          <>
            <div style={{ 
              fontWeight: "bold", 
              color: "#1976d2", 
              marginBottom: "8px",
              fontSize: "16px"
            }}>
              üìç {popupContent.name}
            </div>
            <div style={{ marginBottom: "6px" }}>
              <strong>Tip:</strong> <span style={{ color: "#666" }}>{popupContent.type}</span>
            </div>
            {popupContent.id && (
              <div style={{ marginBottom: "6px", fontSize: "11px", color: "#888" }}>
                <strong>ID:</strong> <span style={{ color: "#666" }}>{popupContent.id}</span>
              </div>
            )}
            <div style={{ 
              fontSize: "12px", 
              color: "#888",
              wordBreak: "break-all",
              maxHeight: "60px",
              overflow: "hidden",
              marginBottom: "8px"
            }}>
              <strong>WKT:</strong> {popupContent.wkt.substring(0, 80)}
              {popupContent.wkt.length > 80 && "..."}
            </div>
            
            {/* Metrik Bilgileri */}
            {popupContent.area !== undefined && (
              <div style={{ fontSize: "11px", color: "#666", marginBottom: "2px" }}>
                <strong>üìê Alan:</strong> {popupContent.area.toFixed(2)} m¬≤
              </div>
            )}
            {popupContent.length !== undefined && (
              <div style={{ fontSize: "11px", color: "#666", marginBottom: "2px" }}>
                <strong>üìè Uzunluk:</strong> {popupContent.length.toFixed(2)} m
              </div>
            )}
            {popupContent.centroid && (
              <div style={{ fontSize: "11px", color: "#666", marginBottom: "2px" }}>
                <strong>üéØ Merkez:</strong> {popupContent.centroid}
              </div>
            )}
            {popupContent.boundingBox && (
              <div style={{ fontSize: "11px", color: "#666", marginBottom: "2px" }}>
                <strong>üì¶ Sƒ±nƒ±r Kutusu:</strong> {popupContent.boundingBox}
              </div>
            )}
            {popupContent.startPoint && (
              <div style={{ fontSize: "11px", color: "#666", marginBottom: "2px" }}>
                <strong>üöÄ Ba≈ülangƒ±√ß:</strong> {popupContent.startPoint}
              </div>
            )}
            {popupContent.endPoint && (
              <div style={{ fontSize: "11px", color: "#666", marginBottom: "2px" }}>
                <strong>üèÅ Biti≈ü:</strong> {popupContent.endPoint}
              </div>
            )}
            
            {/* Butonlar */}
            <div style={{
              display: "flex",
              gap: "4px",
              justifyContent: "space-between",
              marginTop: "8px"
            }}>
              <button
                key="delete-button"
                onClick={() => {
                  console.log("üóëÔ∏è Sil butonuna tƒ±klandƒ±:", {
                    popupContent,
                    hasId: !!popupContent?.id,
                    id: popupContent?.id,
                    hasOnDeleteGeometry: !!onDeleteGeometry
                  });
                  
                  if (onDeleteGeometry && popupContent && popupContent.id) {
                    console.log("üóëÔ∏è Silme i≈ülemi ba≈ülatƒ±lƒ±yor, ID:", popupContent.id);
                    onDeleteGeometry(popupContent.id as number);
                    // Popup'ƒ± kapat
                    if (popupOverlayRef.current) {
                      popupOverlayRef.current.setPosition(undefined);
                      setPopupContent(null);
                    }
                  } else {
                    console.error("‚ùå Silme i√ßin gerekli bilgiler eksik:", {
                      hasOnDeleteGeometry: !!onDeleteGeometry,
                      hasPopupContent: !!popupContent,
                      hasId: !!popupContent?.id,
                      id: popupContent?.id
                    });
                    alert("Bu geometri i√ßin ID bulunamadƒ±!");
                  }
                }}
                style={{
                  padding: "3px 6px",
                  backgroundColor: "#dc3545",
                  color: "white",
                  border: "none",
                  borderRadius: "3px",
                  cursor: "pointer",
                  fontSize: "9px",
                  fontWeight: "600",
                  transition: "background-color 0.2s"
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = "#c82333";
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = "#dc3545";
                }}
              >
                üóëÔ∏è Sil
              </button>
              
              <button
                key="update-button"
                onClick={() => {
                  if (onUpdateGeometry && popupContent) {
                    // Geometri bilgilerini bul - ID ile daha g√ºvenilir
                    const geometry = popupContent.id 
                      ? geometries.find(g => g.id === popupContent.id)
                      : geometries.find(g => g.name === popupContent.name && g.type === popupContent.type);
                    
                    if (geometry) {
                      onUpdateGeometry(geometry);
                    } else {
                      alert("Geometri bulunamadƒ±!");
                    }
                    // Popup'ƒ± kapat
                    if (popupOverlayRef.current) {
                      popupOverlayRef.current.setPosition(undefined);
                      setPopupContent(null);
                    }
                  }
                }}
                style={{
                  padding: "3px 6px",
                  backgroundColor: "#28a745",
                  color: "white",
                  border: "none",
                  borderRadius: "3px",
                  cursor: "pointer",
                  fontSize: "9px",
                  fontWeight: "600",
                  transition: "background-color 0.2s"
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = "#218838";
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = "#28a745";
                }}
              >
                ‚úèÔ∏è G√ºncelle
              </button>
              
              <button
                key="move-button"
                onClick={() => {
                  if (popupContent && popupContent.id) {
                    activateMoveMode(popupContent.id as number);
                    // Popup'ƒ± kapat
                    if (popupOverlayRef.current) {
                      popupOverlayRef.current.setPosition(undefined);
                      setPopupContent(null);
                    }
                  } else {
                    alert("Bu geometri i√ßin ID bulunamadƒ±!");
                  }
                }}
                style={{
                  padding: "3px 6px",
                  backgroundColor: "#007bff",
                  color: "white",
                  border: "none",
                  borderRadius: "3px",
                  cursor: "pointer",
                  fontSize: "9px",
                  fontWeight: "600",
                  transition: "background-color 0.2s"
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = "#0056b3";
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = "#007bff";
                }}
              >
                üñêÔ∏è Ta≈üƒ±
              </button>
            </div>
          </>
        )}
      </div>
    </div>
  );
};

export default MapView;

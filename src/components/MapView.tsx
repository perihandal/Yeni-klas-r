import React, { useEffect, useRef } from "react";
import Map from "ol/Map";
import View from "ol/View";
import TileLayer from "ol/layer/Tile";
import OSM from "ol/source/OSM";
import "ol/ol.css";

import Draw from "ol/interaction/Draw";
import Translate from "ol/interaction/Translate";
import VectorLayer from "ol/layer/Vector";
import VectorSource from "ol/source/Vector";
import { Feature } from "ol";
import { Geometry } from "ol/geom";
import { WKT } from "ol/format";
import { Style, Fill, Stroke, Circle, Text, Icon } from "ol/style";
import Overlay from "ol/Overlay";
import { defaults as defaultInteractions } from "ol/interaction";
import { Collection } from "ol";

// Geometri tipini tanƒ±mla
export interface GeometryItem {
  id?: string | number;
  name?: string;
  type?: string;
  wkt: string;
  highlighted?: boolean;
  area?: number;
  length?: number;
  centroid?: string;
  boundingBox?: string;
  startPoint?: string;
  endPoint?: string;
}


interface MapViewProps {
  geometryType: string;
  onDrawEnd?: (wkt: string) => void;
  geometries?: GeometryItem[];
  zoomToGeometry?: { wkt: string; name?: string } | null;
  onDeleteGeometry?: (id: number) => void;
  onUpdateGeometry?: (geometry: GeometryItem) => void;
  onMoveGeometry?: (id: number, newWkt: string) => void;
}

// Pin/marker stillerini olu≈ütur
const createFeatureStyle = (feature: Feature, geometryType: string, isHighlighted: boolean = false) => {
  const fillColor = getColorByType(geometryType);
  const strokeColor = darkenColor(fillColor);
  
  if (geometryType === 'Point') {
    // Pin ikonunu kullan
    const iconStyle = new Style({
      image: new Icon({
        src: '/pin.png',
        scale: 0.03, // Ultra k√º√ß√ºk boyut
        anchor: [0.5, 1], // Pin'in alt ucu koordinata hizalanƒ±r
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      }),
      text: new Text({
        text: feature.get('name') || '',
        offsetY: -10, // Ultra k√º√ß√ºk pin i√ßin minimal offset
        fill: new Fill({ color: isHighlighted ? '#ff0000' : '#000' }),
        stroke: new Stroke({ 
          color: isHighlighted ? '#ffff00' : '#fff', 
          width: isHighlighted ? 2 : 1 
        }),
        font: isHighlighted ? 'bold 11px Arial' : '10px Arial'
      })
    });
    
    return iconStyle;
  } else if (geometryType === 'LineString') {
    return new Style({
      stroke: new Stroke({
        color: strokeColor,
        width: 3
      })
    });
  } else if (geometryType === 'Polygon') {
    return new Style({
      fill: new Fill({ 
        color: fillColor + '40'
      }),
      stroke: new Stroke({ 
        color: strokeColor, 
        width: 2
      })
    });
  }
  
  // Varsayƒ±lan stil
  return new Style({
    image: new Circle({
      radius: 6,
      fill: new Fill({ color: '#ff0000' }),
      stroke: new Stroke({ color: '#ffffff', width: 2 })
    })
  });
};

// Geometri tipine g√∂re renk
const getColorByType = (type: string): string => {
  switch (type) {
    case 'Point': return '#e74c3c';
    case 'LineString': return '#3498db';
    case 'Polygon': return '#2ecc71';
    default: return '#f39c12';
  }
};

// Rengi koyula≈ütƒ±r
const darkenColor = (color: string): string => {
  const colorMap: { [key: string]: string } = {
    '#e74c3c': '#c0392b',
    '#3498db': '#2980b9',
    '#2ecc71': '#27ae60',
    '#f39c12': '#e67e22'
  };
  return colorMap[color] || color;
};


const MapView: React.FC<MapViewProps> = ({ 
  geometryType, 
  onDrawEnd, 
  geometries = [], 
  zoomToGeometry = null,
  onDeleteGeometry,
  onUpdateGeometry,
  onMoveGeometry
}) => {
  const mapRef = useRef<HTMLDivElement | null>(null);
  const mapInstance = useRef<Map | null>(null);
  const drawRef = useRef<Draw | null>(null);
  const translateRef = useRef<Translate | null>(null);
  const vectorSourceRef = useRef<VectorSource | null>(null);
  const popupRef = useRef<HTMLDivElement | null>(null);
  const popupOverlayRef = useRef<Overlay | null>(null);
  const [mapInitialized, setMapInitialized] = React.useState(false);
  const [mapError, setMapError] = React.useState<string | null>(null);
  const [moveMode, setMoveMode] = React.useState<{ active: boolean; geometryId?: number }>({ active: false });
  const [popupContent, setPopupContent] = React.useState<{ 
    id?: string | number;
    name: string; 
    type: string; 
    wkt: string;
    area?: number;
    length?: number;
    centroid?: string;
    boundingBox?: string;
    startPoint?: string;
    endPoint?: string;
  } | null>(null);
  const hoverTimeoutRef = useRef<number | null>(null);

  // Ta≈üƒ±ma modunu aktifle≈ütir
  const activateMoveMode = (id: number) => {
    console.log("üñêÔ∏è Ta≈üƒ±ma modu aktifle≈ütiriliyor, ID:", id);
    
    if (!mapInstance.current || !vectorSourceRef.current) {
      alert("Harita hen√ºz hazƒ±r deƒüil!");
      return;
    }
    
    // √ñnceki ta≈üƒ±ma interaction'ƒ±nƒ± temizle
    if (translateRef.current) {
      mapInstance.current.removeInteraction(translateRef.current);
      translateRef.current = null;
    }
    
    // Ta≈üƒ±ma modunu aktifle≈ütir
    setMoveMode({ active: true, geometryId: id });
    
    // Ta≈üƒ±ma interaction'ƒ±nƒ± olu≈ütur
    const targetFeature = vectorSourceRef.current.getFeatures().find(feature => feature.get('id') === id);
    if (targetFeature) {
      translateRef.current = new Translate({
        features: new Collection([targetFeature])
      });
    } else {
      alert("Ta≈üƒ±nacak geometri bulunamadƒ±!");
      return;
    }
    
    // Ta≈üƒ±ma tamamlandƒ±ƒüƒ±nda
    translateRef.current.on('translateend', (event) => {
      const feature = event.features.getArray()[0];
      if (feature && onMoveGeometry) {
        const geometry = feature.getGeometry();
        if (geometry) {
          // WKT formatƒ±na √ßevir
          const wktFormat = new WKT();
          const newWkt = wktFormat.writeGeometry(geometry, {
            dataProjection: 'EPSG:4326',
            featureProjection: 'EPSG:3857'
          });
          
          console.log("üîÑ Geometri ta≈üƒ±ndƒ±:", {
            id: feature.get('id'),
            oldWkt: feature.get('wkt'),
            newWkt: newWkt
          });
          
          // Backend'e yeni WKT'yi g√∂nder
          onMoveGeometry(id, newWkt);
          
          // Feature'ƒ±n WKT'sini g√ºncelle
          feature.set('wkt', newWkt);
        }
      }
      
      // Ta≈üƒ±ma modunu kapat
      setMoveMode({ active: false });
      if (translateRef.current) {
        mapInstance.current!.removeInteraction(translateRef.current);
        translateRef.current = null;
      }
      
      alert("Geometri ba≈üarƒ±yla ta≈üƒ±ndƒ±!");
    });
    
    // Ta≈üƒ±ma interaction'ƒ±nƒ± haritaya ekle
    mapInstance.current.addInteraction(translateRef.current);
    
    alert("Ta≈üƒ±ma modu aktifle≈ütirildi! Geometriyi s√ºr√ºkleyebilirsiniz.");
  };

  // Geometrileri haritada g√∂ster
  useEffect(() => {
    console.log("MapView - geometries useEffect √ßalƒ±≈ütƒ±:", {
      geometriesLength: geometries.length,
      mapInitialized,
      hasVectorSource: !!vectorSourceRef.current
    });
    
    if (!vectorSourceRef.current || !mapInitialized) {
      console.log("MapView - Ko≈üullar saƒülanmadƒ±, √ßƒ±kƒ±lƒ±yor");
      return;
    }
    
    try {
      vectorSourceRef.current.clear();
      console.log("Vector source temizlendi");
      
      if (geometries.length > 0) {
        console.log(`MapView - ${geometries.length} geometri i≈ülenecek`);
        const wktFormat = new WKT();
        geometries.forEach((g, index) => {
          try {
            console.log(`\nüîç Geometri ${index + 1} analizi:`, {
              name: g.name,
              type: g.type,
              originalWkt: g.wkt,
              wktType: typeof g.wkt,
              wktLength: g.wkt?.length
            });
            
            // WKT string'inin ba≈üƒ±nda SRID bilgisi var mƒ± kontrol et
            let wktString = g.wkt;
            let projection = 'EPSG:4326';
            
            // Null veya undefined kontrol
            if (!wktString) {
              console.error(`‚ùå Geometri ${index + 1}: WKT verisi bo≈ü`);
              return;
            }
            
            // String olmayan WKT'yi string'e √ßevir
            if (typeof wktString !== 'string') {
              wktString = String(wktString);
              console.log(`‚ö†Ô∏è WKT string'e √ßevrildi:`, wktString);
            }
            
            // SRID=xxxx; formatƒ±nƒ± kontrol et
            if (wktString.includes('SRID=')) {
              const sridMatch = wktString.match(/SRID=(\d+);/);
              if (sridMatch) {
                projection = `EPSG:${sridMatch[1]}`;
                wktString = wktString.replace(/SRID=\d+;/, '');
                console.log(`üåç SRID tespit edildi: ${projection}`);
              }
            } else {
              console.log(`üìç SRID bulunamadƒ±, varsayƒ±lan: ${projection}`);
            }
            
            console.log(`üìù ƒ∞≈ülenecek WKT:`, wktString.substring(0, 100) + "...");
            
            const feature = wktFormat.readFeature(wktString, { 
              dataProjection: projection, 
              featureProjection: 'EPSG:3857' 
            });
            
            console.log(`üîç WKT okuma:`, {
              wktString: wktString.substring(0, 100),
              projection,
              featureProjection: 'EPSG:3857',
              geometryType: feature.getGeometry()?.getType()
            });
            
            // Feature geometrisini kontrol et
            const geometry = feature.getGeometry();
            if (!geometry) {
              console.error(`‚ùå Geometri ${index + 1}: Feature geometrisi bo≈ü`);
              return;
            }
            
            // Koordinatlarƒ± kontrol et (geometry tipine g√∂re)
            let coordinates: any = null;
            if (geometry.getType() === 'Point') {
              coordinates = (geometry as any).getCoordinates();
            } else if (geometry.getType() === 'LineString') {
              coordinates = (geometry as any).getCoordinates();
            } else if (geometry.getType() === 'Polygon') {
              coordinates = (geometry as any).getCoordinates();
            }
            console.log(`üéØ Feature koordinatlarƒ± (EPSG:3857):`, {
              coordinates,
              firstCoord: coordinates?.[0],
              coordCount: coordinates?.length,
              isInRange: coordinates?.[0]?.[0] > 1000000 && coordinates?.[0]?.[1] > 1000000
            });
            
            // Feature'a bilgileri ekle
            if (g.id) {
              feature.set('id', g.id);
            }
            if (g.name) {
              feature.set('name', g.name);
            }
            if (g.type) {
              feature.set('type', g.type);
            } else {
              // Eƒüer tip belirtilmemi≈üse WKT'den √ßƒ±kar
              const wktType = wktString.split('(')[0].trim();
              feature.set('type', wktType);
            }
            
            // Highlight bilgisini ekle
            const isHighlighted = g.highlighted || false;
            feature.set('highlighted', isHighlighted);
            
            // WKT bilgisini de ekle
            feature.set('wkt', g.wkt);
            

            
            // Feature'a stil uygula
            const featureStyle = createFeatureStyle(feature, feature.get('type') || 'Point', isHighlighted);
            feature.setStyle(featureStyle);
            
            // Feature'ƒ± eklemeden √∂nce extent kontrol√º
            const extent = geometry.getExtent();
            console.log(`üì¶ Geometri extent:`, extent);
            
        vectorSourceRef.current!.addFeature(feature);
            console.log(`üìç Pin stili uygulandƒ±:`, {
              type: feature.get('type'),
              name: feature.get('name'),
              hasStyle: !!feature.getStyle(),
              isPoint: feature.get('type') === 'Point',
              isHighlighted: isHighlighted,
              iconSrc: feature.get('type') === 'Point' ? '/pin.png' : 'N/A',
              iconScale: feature.get('type') === 'Point' ? '0.03 (ultra mini)' : 'N/A'
            });
            console.log(`‚úÖ Geometri ba≈üarƒ±yla eklendi:`, {
              name: g.name || 'ƒ∞simsiz',
              type: g.type,
              projection,
              geometryType: geometry.getType(),
              coordinates: coordinates,
              extent: extent
            });
          } catch (err) {
            console.error('‚ùå Geometry format hatasƒ±:', {
              name: g.name,
              wkt: g.wkt,
              error: err
            });
          }
        });
        
        const totalFeatures = vectorSourceRef.current.getFeatures().length;
        console.log(`üéØ Toplam ${totalFeatures} feature vector source'a eklendi`);
        
        // Harita g√∂r√ºn√ºm alanƒ±nƒ± kontrol et (T√ºrkiye sƒ±nƒ±rlarƒ± i√ßinde tutmaya √ßalƒ±≈ü)
        if (mapInstance.current && totalFeatures > 0) {
          const view = mapInstance.current.getView();
          const currentCenter = view.getCenter();
          const currentZoom = view.getZoom();
          
          console.log(`üó∫Ô∏è Harita g√∂r√ºn√ºm bilgileri:`, {
            center: currentCenter,
            zoom: currentZoom
          });
          
          // Vector source'un extent'ini kontrol et
          const vectorExtent = vectorSourceRef.current.getExtent();
          console.log(`üì¶ Vector source extent:`, vectorExtent);
          
          // Geometrilerin extent'ine zoom yap
          if (vectorExtent && vectorExtent.every(val => isFinite(val))) {
            console.log(`üéØ Geometrilerin extent'ine zoom yapƒ±lƒ±yor`);
            view.fit(vectorExtent, { 
              padding: [20, 20, 20, 20],
              duration: 800
            });
          }
        }
      } else {
        console.log("‚ö†Ô∏è Hi√ß geometri bulunamadƒ±");
      }
    } catch (err) {
      console.error('üî• Geometri g√∂r√ºnt√ºleme hatasƒ±:', err);
    }
  }, [geometries, mapInitialized]);

  // Belirli geometriye zoom yapma
  useEffect(() => {
    console.log("üîÑ zoomToGeometry useEffect √ßalƒ±≈ütƒ±:", {
      hasMapInstance: !!mapInstance.current,
      hasZoomToGeometry: !!zoomToGeometry,
      mapInitialized,
      zoomToGeometry
    });
    
    if (!mapInstance.current || !zoomToGeometry || !mapInitialized) {
      console.log("‚ùå Zoom yapƒ±lamƒ±yor - ko≈üullar saƒülanmadƒ±");
      return;
    }
    
    console.log("üéØ Geometriye zoom yapƒ±lƒ±yor:", zoomToGeometry);
    
    try {
      const wktFormat = new WKT();
      const feature = wktFormat.readFeature(zoomToGeometry.wkt, {
        dataProjection: 'EPSG:4326',
        featureProjection: 'EPSG:3857'
      });
      
      const geometry = feature.getGeometry();
      if (!geometry) {
        console.error("‚ùå Zoom i√ßin geometri olu≈üturulamadƒ±");
        return;
      }
      
      const extent = geometry.getExtent();
      const view = mapInstance.current.getView();
      
      console.log("üì¶ Zoom extent:", extent);
      
      // Geometri tipine g√∂re zoom yap
      if (geometry.getType() === 'Point') {
        const coordinates = (geometry as any).getCoordinates();
        view.animate({
          center: coordinates,
          zoom: 15,
          duration: 1500
        });
        console.log(`üìç Nokta i√ßin zoom`);
      } else {
        // Diƒüer geometriler i√ßin fit kullan
        view.fit(extent, {
          padding: [20, 20, 20, 20],
          duration: 1500
        });
        console.log(`üìè √áizgi/alan i√ßin fit zoom`);
      }
      
      // Zoom tamamlandƒ±ktan sonra bilgi ver
      setTimeout(() => {
        console.log("‚úÖ Zoom tamamlandƒ±:", {
          name: zoomToGeometry.name,
          newCenter: view.getCenter(),
          newZoom: view.getZoom(),
          geometryType: geometry.getType()
        });
      }, 1600);
      
    } catch (err) {
      console.error("‚ùå Zoom hatasƒ±:", err);
    }
  }, [zoomToGeometry, mapInitialized]);

  // Harita ba≈ülatma
  useEffect(() => {
    if (mapRef.current && !mapInstance.current) {
      try {
      vectorSourceRef.current = new VectorSource();
        const vectorLayer = new VectorLayer({ 
          source: vectorSourceRef.current,
          style: (feature: any) => {
            const featureType = feature.get('type') || 'Point';
            const isHighlighted = feature.get('highlighted') || false;
            return createFeatureStyle(feature as Feature, featureType, isHighlighted);
          }
        });
        
        // Popup overlay olu≈ütur
        if (popupRef.current) {
          popupOverlayRef.current = new Overlay({
            element: popupRef.current,
            autoPan: false, // Harita kaymasƒ±nƒ± engelle
            offset: [0, -15], // Popup'u biraz yukarƒ± kaydƒ±r
            positioning: 'bottom-center' // Alt ortadan pozisyonla
          });
        }

      mapInstance.current = new Map({
        target: mapRef.current,
        layers: [
          new TileLayer({ source: new OSM() }),
          vectorLayer,
        ],
        overlays: popupOverlayRef.current ? [popupOverlayRef.current] : [],
        interactions: defaultInteractions(), // T√ºm varsayƒ±lan etkile≈üimleri aktif et
        view: new View({
          center: [3924862.6, 4865942.2], // T√ºrkiye'nin EPSG:3857'deki merkezi
          zoom: 6,
          projection: 'EPSG:3857',
          enableRotation: false, // D√∂nd√ºrmeyi kapat
          constrainResolution: false // Zoom kƒ±sƒ±tlamasƒ±nƒ± kaldƒ±r
        }),
      });

        // Mouse hover event'leri ekle (daha stabil)
        let currentFeature: any = null;
        
        mapInstance.current.on('pointermove', (evt) => {
          const feature = mapInstance.current!.forEachFeatureAtPixel(evt.pixel, (feature) => feature);
          
          // Popup'ƒ±n √ºzerindeyse hi√ßbir ≈üey yapma
          if (popupRef.current && popupRef.current.contains(evt.originalEvent.target as Node)) {
            return;
          }
          
          // Eƒüer aynƒ± feature √ºzerindeyse hi√ßbir ≈üey yapma
          if (feature === currentFeature) {
            return;
          }
          
          // √ñnceki timeout'u temizle
          if (hoverTimeoutRef.current) {
            clearTimeout(hoverTimeoutRef.current);
          }
          
          currentFeature = feature;
          
          // Daha uzun gecikme ile hover i≈ülemini yap
          hoverTimeoutRef.current = setTimeout(() => {
            if (feature && popupOverlayRef.current) {
              const name = feature.get('name') || 'ƒ∞simsiz';
              const type = feature.get('type') || 'Bilinmeyen';
              const coordinates = evt.coordinate;
              
              // Geometri verilerini bul
              const geometryData = geometries.find(g => g.name === name && g.type === type);
              
              setPopupContent({
                id: feature.get('id') || geometryData?.id,
                name: name,
                type: type,
                wkt: feature.get('wkt') || 'WKT bilgisi yok',
                area: geometryData?.area,
                length: geometryData?.length,
                centroid: geometryData?.centroid,
                boundingBox: geometryData?.boundingBox,
                startPoint: geometryData?.startPoint,
                endPoint: geometryData?.endPoint
              });
              
              popupOverlayRef.current.setPosition(coordinates);
              console.log("üìç Popup g√∂steriliyor:", { 
                name, 
                type, 
                id: feature.get('id'),
                geometryDataId: geometryData?.id,
                finalId: feature.get('id') || geometryData?.id
              });
            } else if (popupOverlayRef.current) {
              popupOverlayRef.current.setPosition(undefined);
              setPopupContent(null);
            }
          }, 300); // 300ms gecikme ile titre≈üimi tamamen √∂nle
        });

        // Zoom deƒüi≈üikliklerini dinle
        mapInstance.current.getView().on('change:resolution', () => {
          const zoom = mapInstance.current!.getView().getZoom();
          console.log("üîç Zoom seviyesi deƒüi≈üti:", zoom);
        });

        // Mouse wheel event'ini test et
        mapRef.current.addEventListener('wheel', (e) => {
          console.log("üñ±Ô∏è Mouse wheel event algƒ±landƒ±:", {
            deltaY: e.deltaY,
            ctrlKey: e.ctrlKey,
            preventDefault: true
          });
        });

        // Harita y√ºklenme kontrol√º
        mapInstance.current.on('rendercomplete', () => {
          setMapInitialized(true);
          setMapError(null);
          

          
          // Interaction'larƒ± kontrol et
          const view = mapInstance.current!.getView();
          const interactions = mapInstance.current!.getInteractions();
          const interactionNames = interactions.getArray().map(i => i.constructor.name);
          
          console.log("üó∫Ô∏è Harita ba≈ülatƒ±ldƒ± - Zoom kontrol√º aktif:", {
            currentZoom: view.getZoom(),
            minZoom: view.getMinZoom(),
            maxZoom: view.getMaxZoom(),
            interactions: interactionNames,
            hasMouseWheelZoom: interactionNames.includes('MouseWheelZoom'),
            hasDoubleClickZoom: interactionNames.includes('DoubleClickZoom'),
            totalInteractions: interactions.getLength()
          });
        });

        // Tile y√ºkleme hata kontrol√º
        mapInstance.current.getLayers().forEach(layer => {
          if (layer instanceof TileLayer) {
            layer.getSource()?.on('tileloaderror', () => {
              setMapError('Harita katmanlarƒ± y√ºklenemedi. ƒ∞nternet baƒülantƒ±nƒ±zƒ± kontrol edin.');
            });
          }
        });

      } catch (err) {
        console.error('Harita ba≈ülatma hatasƒ±:', err);
        setMapError('Harita ba≈ülatƒ±lamadƒ±: ' + (err as Error).message);
      }
    }
    
    return () => {
      // Timeout'u temizle
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
      
      if (mapInstance.current) {
        mapInstance.current.setTarget(undefined);
        mapInstance.current = null;
      }
    };
  }, []);

  // √áizim interaction'ƒ±
  useEffect(() => {
    console.log(`üîß Draw interaction kontrol√º:`, {
      hasMapInstance: !!mapInstance.current,
      hasVectorSource: !!vectorSourceRef.current,
      mapInitialized,
      geometryType
    });
    
    if (!mapInstance.current || !vectorSourceRef.current || !mapInitialized) {
      console.log(`‚ùå Draw interaction eklenmedi - eksik bile≈üenler`);
      return;
    }
    
    if (drawRef.current) {
      mapInstance.current.removeInteraction(drawRef.current);
      drawRef.current = null;
    }
    
    if (geometryType) {
      try {
      drawRef.current = new Draw({
        source: vectorSourceRef.current,
        type: geometryType as any,
          style: createFeatureStyle(new Feature(), geometryType)
      });
      mapInstance.current.addInteraction(drawRef.current);
        
      drawRef.current.on('drawend', (evt) => {
          try {
        const feature = (evt as any).feature as Feature<Geometry>;
            
            // √áizilen feature'a tip bilgisi ekle
            feature.set('type', geometryType);
            
            // Stil uygula
            const featureStyle = createFeatureStyle(feature, geometryType);
            feature.setStyle(featureStyle);
            
            const wkt = new WKT().writeFeature(feature, {
              dataProjection: 'EPSG:4326',
              featureProjection: 'EPSG:3857'
            });
            
            // WKT'yi doƒürudan kullan
            const finalWkt = wkt;
            
            console.log(`üé® √áizilen geometri WKT:`, {
              type: geometryType,
              originalWkt: wkt,
              finalWkt: finalWkt
            });
            
            console.log(`üé® √áizilen geometriye stil uygulandƒ±:`, {
              type: geometryType,
              hasStyle: !!feature.getStyle(),
              isPoint: geometryType === 'Point',
              usingIcon: geometryType === 'Point' ? 'pin.png' : false
            });
            
            // √áizilen feature'ƒ± vector source'a ekle
            if (vectorSourceRef.current) {
              const beforeCount = vectorSourceRef.current.getFeatures().length;
              vectorSourceRef.current.addFeature(feature);
              const afterCount = vectorSourceRef.current.getFeatures().length;
              
              console.log(`‚úÖ Feature vector source'a eklendi:`, {
                type: geometryType,
                beforeCount,
                afterCount,
                geometry: feature.getGeometry()?.getType(),
                coordinates: (feature.getGeometry() as any)?.getCoordinates?.()
              });
              
              // T√ºm feature'larƒ± listele
              console.log(`üìã Vector source'daki t√ºm feature'lar:`, 
                vectorSourceRef.current.getFeatures().map(f => ({
                  type: f.get('type'),
                  name: f.get('name'),
                  geometry: f.getGeometry()?.getType()
                }))
              );
            }
            
            // LineString √ßizimi tamamlandƒ±ysa sadece LineString'i g√∂nder
            if (geometryType === 'LineString' && onDrawEnd) {
              console.log('üîó LineString g√∂nderiliyor:', finalWkt);
              onDrawEnd(finalWkt);
            } else if (onDrawEnd) {
              onDrawEnd(finalWkt);
            }
          } catch (err) {
            console.error('√áizim tamamlama hatasƒ±:', err);
        }
      });
      } catch (err) {
        console.error('√áizim interaction hatasƒ±:', err);
      }
    }
    
    // Temizlik
    return () => {
      if (drawRef.current && mapInstance.current) {
        mapInstance.current.removeInteraction(drawRef.current);
      }
    };
  }, [geometryType, onDrawEnd, mapInitialized]);

  return (
    <div style={{ width: "100%", height: "100%", minHeight: 0, position: "relative" }}>
      <div ref={mapRef} className="ol-map-container" style={{ width: "100%", height: "100%", minHeight: 0 }} />
      {mapError && (
        <div style={{
          position: "absolute",
          top: "10px",
          left: "10px",
          right: "10px",
          background: "#ff5722",
          color: "white",
          padding: "10px",
          borderRadius: "4px",
          zIndex: 1000,
          fontSize: "14px"
        }}>
          {mapError}
        </div>
      )}
      {!mapInitialized && !mapError && (
        <div style={{
          position: "absolute",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          background: "rgba(255,255,255,0.9)",
          padding: "20px",
          borderRadius: "8px",
          fontSize: "16px",
          color: "#666"
        }}>
          Harita y√ºkleniyor...
        </div>
      )}
      
      {/* Ta≈üƒ±ma Modu G√∂stergesi */}
      {moveMode.active && (
        <div style={{
          position: "absolute",
          top: "10px",
          left: "50%",
          transform: "translateX(-50%)",
          background: "#ff9800",
          color: "white",
          padding: "8px 16px",
          borderRadius: "4px",
          fontSize: "14px",
          fontWeight: "bold",
          zIndex: 1000,
          boxShadow: "0 2px 8px rgba(0,0,0,0.3)"
        }}>
          üñêÔ∏è Ta≈üƒ±ma Modu Aktif - Geometriyi s√ºr√ºkleyin
        </div>
      )}
      
            {/* Popup Element */}
      <div
        ref={popupRef}
        style={{
          background: "white",
          border: "2px solid #1976d2",
          borderRadius: "8px",
          padding: "12px",
          fontSize: "14px",
          boxShadow: "0 4px 12px rgba(0,0,0,0.3)",
          maxWidth: "300px",
          display: popupContent ? "block" : "none",
          position: "relative",
          zIndex: 10000,
          pointerEvents: "auto" // Mouse eventlerini etkinle≈ütir
        }}
        onMouseEnter={() => {
          // Popup'ƒ±n √ºzerindeyken hover timeout'unu temizle
          if (hoverTimeoutRef.current) {
            clearTimeout(hoverTimeoutRef.current);
          }
        }}
        onMouseLeave={() => {
          // Popup'tan √ßƒ±kƒ±nca popup'ƒ± kapat
          setTimeout(() => {
            if (popupOverlayRef.current) {
              popupOverlayRef.current.setPosition(undefined);
              setPopupContent(null);
            }
          }, 200);
        }}
      >
        {popupContent && (
          <>
            <div style={{ 
              fontWeight: "bold", 
              color: "#1976d2", 
              marginBottom: "8px",
              fontSize: "16px"
            }}>
              üìç {popupContent.name}
            </div>
            <div style={{ marginBottom: "6px" }}>
              <strong>Tip:</strong> <span style={{ color: "#666" }}>{popupContent.type}</span>
            </div>
            {popupContent.id && (
              <div style={{ marginBottom: "6px", fontSize: "11px", color: "#888" }}>
                <strong>ID:</strong> <span style={{ color: "#666" }}>{popupContent.id}</span>
              </div>
            )}
            <div style={{ 
              fontSize: "12px", 
              color: "#888",
              wordBreak: "break-all",
              maxHeight: "60px",
              overflow: "hidden",
              marginBottom: "8px"
            }}>
              <strong>WKT:</strong> {popupContent.wkt.substring(0, 80)}
              {popupContent.wkt.length > 80 && "..."}
            </div>
            
            {/* Metrik Bilgileri */}
            {popupContent.area !== undefined && (
              <div style={{ fontSize: "11px", color: "#666", marginBottom: "2px" }}>
                <strong>üìê Alan:</strong> {popupContent.area.toFixed(2)} m¬≤
              </div>
            )}
            {popupContent.length !== undefined && (
              <div style={{ fontSize: "11px", color: "#666", marginBottom: "2px" }}>
                <strong>üìè Uzunluk:</strong> {popupContent.length.toFixed(2)} m
              </div>
            )}
            {popupContent.centroid && (
              <div style={{ fontSize: "11px", color: "#666", marginBottom: "2px" }}>
                <strong>üéØ Merkez:</strong> {popupContent.centroid}
              </div>
            )}
            {popupContent.boundingBox && (
              <div style={{ fontSize: "11px", color: "#666", marginBottom: "2px" }}>
                <strong>üì¶ Sƒ±nƒ±r Kutusu:</strong> {popupContent.boundingBox}
              </div>
            )}
            {popupContent.startPoint && (
              <div style={{ fontSize: "11px", color: "#666", marginBottom: "2px" }}>
                <strong>üöÄ Ba≈ülangƒ±√ß:</strong> {popupContent.startPoint}
              </div>
            )}
            {popupContent.endPoint && (
              <div style={{ fontSize: "11px", color: "#666", marginBottom: "2px" }}>
                <strong>üèÅ Biti≈ü:</strong> {popupContent.endPoint}
              </div>
            )}
            
            {/* Butonlar */}
            <div style={{
              display: "flex",
              gap: "4px",
              justifyContent: "space-between",
              marginTop: "8px"
            }}>
              <button
                key="delete-button"
                onClick={() => {
                  console.log("üóëÔ∏è Sil butonuna tƒ±klandƒ±:", {
                    popupContent,
                    hasId: !!popupContent?.id,
                    id: popupContent?.id,
                    hasOnDeleteGeometry: !!onDeleteGeometry
                  });
                  
                  if (onDeleteGeometry && popupContent && popupContent.id) {
                    console.log("üóëÔ∏è Silme i≈ülemi ba≈ülatƒ±lƒ±yor, ID:", popupContent.id);
                    onDeleteGeometry(popupContent.id as number);
                    // Popup'ƒ± kapat
                    if (popupOverlayRef.current) {
                      popupOverlayRef.current.setPosition(undefined);
                      setPopupContent(null);
                    }
                  } else {
                    console.error("‚ùå Silme i√ßin gerekli bilgiler eksik:", {
                      hasOnDeleteGeometry: !!onDeleteGeometry,
                      hasPopupContent: !!popupContent,
                      hasId: !!popupContent?.id,
                      id: popupContent?.id
                    });
                    alert("Bu geometri i√ßin ID bulunamadƒ±!");
                  }
                }}
                style={{
                  padding: "3px 6px",
                  backgroundColor: "#dc3545",
                  color: "white",
                  border: "none",
                  borderRadius: "3px",
                  cursor: "pointer",
                  fontSize: "9px",
                  fontWeight: "600",
                  transition: "background-color 0.2s"
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = "#c82333";
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = "#dc3545";
                }}
              >
                üóëÔ∏è Sil
              </button>
              
              <button
                key="update-button"
                onClick={() => {
                  if (onUpdateGeometry && popupContent) {
                    // Geometri bilgilerini bul - ID ile daha g√ºvenilir
                    const geometry = popupContent.id 
                      ? geometries.find(g => g.id === popupContent.id)
                      : geometries.find(g => g.name === popupContent.name && g.type === popupContent.type);
                    
                    if (geometry) {
                      onUpdateGeometry(geometry);
                    } else {
                      alert("Geometri bulunamadƒ±!");
                    }
                    // Popup'ƒ± kapat
                    if (popupOverlayRef.current) {
                      popupOverlayRef.current.setPosition(undefined);
                      setPopupContent(null);
                    }
                  }
                }}
                style={{
                  padding: "3px 6px",
                  backgroundColor: "#28a745",
                  color: "white",
                  border: "none",
                  borderRadius: "3px",
                  cursor: "pointer",
                  fontSize: "9px",
                  fontWeight: "600",
                  transition: "background-color 0.2s"
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = "#218838";
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = "#28a745";
                }}
              >
                ‚úèÔ∏è G√ºncelle
              </button>
              
              <button
                key="move-button"
                onClick={() => {
                  if (popupContent && popupContent.id) {
                    activateMoveMode(popupContent.id as number);
                    // Popup'ƒ± kapat
                    if (popupOverlayRef.current) {
                      popupOverlayRef.current.setPosition(undefined);
                      setPopupContent(null);
                    }
                  } else {
                    alert("Bu geometri i√ßin ID bulunamadƒ±!");
                  }
                }}
                style={{
                  padding: "3px 6px",
                  backgroundColor: "#007bff",
                  color: "white",
                  border: "none",
                  borderRadius: "3px",
                  cursor: "pointer",
                  fontSize: "9px",
                  fontWeight: "600",
                  transition: "background-color 0.2s"
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = "#0056b3";
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = "#007bff";
                }}
              >
                üñêÔ∏è Ta≈üƒ±
              </button>
            </div>
          </>
        )}
      </div>
    </div>
  );
};

export default MapView;
